<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import pathlib
from typing import List
import zipfile
import Module.Logs.logs as log
import Module.Persistence.connection as con
import hashlib as hlib
import re
import shutil
from datetime import date, datetime
from dotenv import load_dotenv


class get_files:
    &#34;&#34;&#34;Class to get and process obtained objects from S3 buckets for interpretation.&#34;&#34;&#34;
    def __init__(self):
        load_dotenv()
        self.sql = con.connect_to_postgreSQL()
        self.s3 = con.connect_to_s3()
        self.landing = os.getenv(&#34;LANDING_BUCKET&#34;)
        self.log = os.getenv(&#34;LOG_BUCKET&#34;)
        self.raw = os.getenv(&#34;RAW_BUCKET&#34;)
        self.module = &#34;GET FILES&#34;

    def hash_file(self, filename: str) -&gt; str:
        &#34;&#34;&#34;Obtains the hash code of the file to identify any changes

        Args:
            filename (str) : local file path

        Returns:
            str : Hash code generated
        
        &#34;&#34;&#34;
        hash = hlib.sha256()
        block_size = 65536
        with open(filename, &#34;rb&#34;) as file:
            while True:
                data = file.read(block_size)
                if not data:
                    break
                hash.update(data)
        return hash.hexdigest()

    def get_clients(self, client: str = None) -&gt; list:
        &#34;&#34;&#34;Get client&#39;s data or a list of clients
        
        Args:
            client (str) : clients code, or None if needed.
            
        Returns:
            select (list) : gets one or several clients data.
        
        &#34;&#34;&#34;
        try:
            if client == None:
                select = self.sql.select(
                    &#34;CONTROL.T_CUSTOMER&#34;, &#34;WHERE status = &#39;ACTIVE&#39;&#34;
                )
                return select
            else:
                select = self.sql.select(
                    &#34;CONTROL.T_CUSTOMER&#34;, f&#34;WHERE status = &#39;ACTIVE&#39; and code=&#39;{client}&#39;&#34;
                )
                return select
        except ValueError as error:
            return error

    def get_files_from_s3(self, client: str, log_name: str, file: str) -&gt; dict:
        &#34;&#34;&#34;Get files from client&#39;s S3 repository
        
        Args:
            client (str) : clients code.
            log_name (str): log file name.
            file (str): file name.
            
        Returns:
            dict : generated file paths data .
        
        &#34;&#34;&#34;
        date_of_extract = datetime.now()
        formated_date = (
            str(date_of_extract.year)
            + str(date_of_extract.month)
            + str(date_of_extract.day)
            + &#34;_&#34;
            + str(int(datetime.timestamp(date_of_extract)))
        )
        path_to_file = &#34;FILES/&#34; + client + &#34;/&#34; + formated_date
        shutil.rmtree(path_to_file, True)
        pathlib.Path(path_to_file).mkdir(parents=True, exist_ok=True)
        customer_files = self.s3.list_content(self.landing, client + &#34;/&#34; + file)
        for file_obj in customer_files:
            get_zip_name = pathlib.Path(file_obj).name
            if file_obj != (client + &#34;/&#34;):
                log.logs().exist_file(
                    &#34;OPERATIONAL&#34;,
                    client,
                    &#34;INTELICA&#34;,
                    log_name,
                    &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                    &#34;INFO&#34;,
                    &#34;Get file:&#34; + get_zip_name,
                    self.module
                )
                self.s3.get_object(
                    self.landing, file_obj, path_to_file + &#34;/&#34; + get_zip_name
                )
        listofdir = os.listdir(path_to_file)
        for k in listofdir:
            extension = pathlib.Path(k).suffix
            name = pathlib.Path(k).stem
            complete_path = path_to_file + &#34;/&#34; + k
            parent = &#34;&#34;
            if extension == &#34;.zip&#34;:
                log.logs().exist_file(
                    &#34;OPERATIONAL&#34;,
                    client,
                    &#34;INTELICA&#34;,
                    log_name,
                    &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                    &#34;INFO&#34;,
                    &#34;Unzipping file: &#34; + k,
                    self.module
                )
                new_path = path_to_file + &#34;/&#34; + name
                self.unzip_nested(new_path, complete_path, path_to_file, name)
                parent = k
            log.logs().exist_file(
                &#34;OPERATIONAL&#34;,
                client,
                &#34;INTELICA&#34;,
                log_name,
                &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                &#34;INFO&#34;,
                &#34;Start of upload of file: &#34; + client + &#34;/&#34; + formated_date + &#34;/&#34; + k,
                self.module
            )
            self.s3.upload_object(
                self.raw, complete_path, client + &#34;/&#34; + formated_date + &#34;/&#34; + k
            )
            log.logs().exist_file(
                &#34;OPERATIONAL&#34;,
                client,
                &#34;INTELICA&#34;,
                log_name,
                &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                &#34;INFO&#34;,
                &#34;File uploaded on route : &#34; + client + &#34;/&#34; + formated_date + &#34;/&#34; + k,
                self.module
            )

        log.logs().exist_file(
            &#34;OPERATIONAL&#34;,
            client,
            &#34;INTELICA&#34;,
            log_name,
            &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
            &#34;INFO&#34;,
            client + &#34; files moved to repository&#34;,
            self.module
        )
        files = self.sort_files(client, log_name, path_to_file, formated_date)
        self.clean_path(path_to_file)
        return {
            &#34;client&#34;: client,
            &#34;path_to_files&#34;: path_to_file,
            &#34;log_name&#34;: log_name,
            &#34;status&#34;: &#34;finalized&#34;,
            &#34;list_of_files&#34;: files,
            &#34;execution_folder&#34;: formated_date,
        }

    def sort_files(
        self, client, log_name, path_to_files: str, execution_folder: str
    ) -&gt; list:
        &#34;&#34;&#34;navigate and sort files to folders
        
        Args:
            client (str): client code.
            log_name (str): log name file.
            path_to_files (str): path to local files.
            execution_folder (str): parent execution folder.

        Returns:
            list_of_files (list): list of dicts with file data.
        
        &#34;&#34;&#34;
        exclude = [&#34;MASTERCARD&#34;, &#34;VISA&#34;, &#34;OTHER&#34;, &#34;CHECK&#34;, &#34;RESULT&#34;]
        list_of_files = []
        for file in os.listdir(path_to_files):
            if os.path.isdir(path_to_files + &#34;/&#34; + file):
                if file not in exclude:
                    filename = os.fsdecode(file)
                    if filename.endswith(&#34;.zip&#34;):
                        continue
                    else:
                        for file_sub in os.listdir(path_to_files + &#34;/&#34; + file):
                            clasified_file = self.sort_by_name(
                                path_to_files + &#34;/&#34; + file + &#34;/&#34; + file_sub,
                                path_to_files,
                                client,
                            )
                            list_of_files.append(clasified_file)
                            if (
                                clasified_file[&#34;filetype&#34;] == &#34;IN&#34;
                                or clasified_file[&#34;filetype&#34;] == &#34;OUT&#34;
                            ):
                                status = &#34;IN PROGRESS&#34;
                            elif (clasified_file[&#34;filetype&#34;] == &#34;OTHER&#34; or clasified_file[&#34;filetype&#34;] == &#34;CHECK&#34;):
                                status = &#34;REVISION&#34;
                                log.logs().exist_file(
                                    &#34;OPERATIONAL&#34;,
                                    client,
                                    &#34;INTELICA&#34;,
                                    log_name,
                                    &#34;SORTING FILES&#34;,
                                    &#34;WARNING&#34;,
                                    f&#34;File {clasified_file[&#39;path&#39;]} connot be sorted properly.&#34;,
                                    self.module
                                )
                            else:
                                status = &#34;FINISHED&#34;
                            control_files = [
                                (
                                    clasified_file[&#34;hash&#34;],
                                    clasified_file[&#34;brand&#34;],
                                    client,
                                    log_name,
                                    clasified_file[&#34;path&#34;],
                                    date.today(),
                                    date.today(),
                                    &#34;Sorting files&#34;,
                                    status,
                                    clasified_file[&#34;filetype&#34;],
                                    f&#34;{file}.zip&#34;,
                                    execution_folder,
                                )
                            ]
                            con.connect_to_postgreSQL().insert_control_file(
                                control_files
                            )

            else:
                filename = os.fsdecode(file)
                if filename.endswith(&#34;.zip&#34;):
                    continue
                else:
                    clasified_file = self.sort_by_name(
                        path_to_files + &#34;/&#34; + file, path_to_files, client
                    )
                    list_of_files.append(clasified_file)
                    if (
                        clasified_file[&#34;filetype&#34;] == &#34;IN&#34;
                        or clasified_file[&#34;filetype&#34;] == &#34;OUT&#34;
                    ):
                        status = &#34;IN PROGRESS&#34;
                    elif (clasified_file[&#34;filetype&#34;] == &#34;OTHER&#34; or clasified_file[&#34;filetype&#34;] == &#34;CHECK&#34;):
                        status = &#34;REVISION&#34;
                        log.logs().exist_file(
                            &#34;OPERATIONAL&#34;,
                            client,
                            &#34;INTELICA&#34;,
                            log_name,
                            &#34;SORTING FILES&#34;,
                            &#34;WARNING&#34;,
                            f&#34;File {clasified_file[&#39;path&#39;]} connot be sorted properly.&#34;,
                            self.module
                        )
                        
                    else:
                        status = &#34;FINISHED&#34;
                    control_files = [
                        (
                            clasified_file[&#34;hash&#34;],
                            clasified_file[&#34;brand&#34;],
                            client,
                            log_name,
                            clasified_file[&#34;path&#34;],
                            date.today(),
                            date.today(),
                            &#34;Sorted file&#34;,
                            status,
                            clasified_file[&#34;filetype&#34;],
                            &#34;&#34;,
                            execution_folder,
                        )
                    ]
                    con.connect_to_postgreSQL().insert_control_file(control_files)

        return list_of_files

    def sort_by_name(self, path_file: str, path_root: str, client: str) -&gt; dict:
        &#34;&#34;&#34;Creates and sort by brand and file type
        
        Args:
            client (str): client code.
            path_file (str): path to file.
            path_root (str): path to root folder of execution.

        Returns:
            dict : dict with file info.
        
        &#34;&#34;&#34;
        filename = pathlib.Path(path_file).name
        path_MCIN = path_root + &#34;/MASTERCARD/IN&#34;
        path_MCOUT = path_root + &#34;/MASTERCARD/OUT&#34;
        path_MCOTHER = path_root + &#34;/MASTERCARD/OTHER&#34;
        path_VIIN = path_root + &#34;/VISA/IN&#34;
        path_VIOUT = path_root + &#34;/VISA/OUT&#34;
        path_VIOTHER = path_root + &#34;/VISA/OTHER&#34;
        path_OTHER = path_root + &#34;/OTHER&#34;
        path_CHECK = path_root + &#34;/CHECK&#34;
        pathlib.Path(path_MCIN).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_MCOUT).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_MCOTHER).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_VIIN).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_VIOUT).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_VIOTHER).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_OTHER).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_CHECK).mkdir(parents=True, exist_ok=True)
        query = &#34;where customer_code in(&#39;&#34; + client + &#34;&#39;,&#39;ALL&#39;)&#34;
        list_regex = con.connect_to_postgreSQL().select(
            &#34;control.t_regex&#34;, query, [&#34;file_format&#34;, &#34;file_type&#34;]
        )
        filetype = &#34;OTHER&#34;

        regex_in_MI = []
        regex_in_MO = []
        regex_in_MCO = []
        regex_in_VI = []
        regex_in_VO = []
        regex_in_VIO = []

        for i in list_regex:

            if i[&#34;file_type&#34;] == &#34;MC Incoming&#34;:
                regex_in_MI.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;MC Outgoing&#34;:
                regex_in_MO.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;IAR (T067)&#34;:
                regex_in_MCO.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;VI Incoming&#34;:
                regex_in_VI.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;VI Outgoing&#34;:
                regex_in_VO.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;ARDEF (EP302)&#34;:
                regex_in_VIO.append(i[&#34;file_format&#34;])

        matches = 0

        for i in regex_in_MI:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;MC/MI&#34;
                matches += 1
                break

        for i in regex_in_MO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;MC/MO&#34;
                matches += 1
                break

        for i in regex_in_MCO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;MC/MCOTHER&#34;
                matches += 1
                break

        for i in regex_in_VI:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;VI/VI&#34;
                matches += 1
                break

        for i in regex_in_VO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;VI/VOUT&#34;
                matches += 1
                break

        for i in regex_in_VIO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;VI/VOTHER&#34;
                matches += 1
                break

        if matches &gt; 1:
            filetype = &#34;CHECK&#34;

        if filetype == &#34;MC/MI&#34;:
            path_to_ordened_file = path_MCIN + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;MC&#34;
            filetype = &#34;IN&#34;

        elif filetype == &#34;MC/MO&#34;:
            path_to_ordened_file = path_MCOUT + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;MC&#34;
            filetype = &#34;OUT&#34;

        elif filetype == &#34;MC/MCOTHER&#34;:
            path_to_ordened_file = path_MCOTHER + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;MC&#34;
            filetype = &#34;MC/OTHER&#34;

        elif filetype == &#34;VI/VI&#34;:
            path_to_ordened_file = path_VIIN + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;VI&#34;
            filetype = &#34;IN&#34;

        elif filetype == &#34;VI/VOUT&#34;:
            path_to_ordened_file = path_VIOUT + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;VI&#34;
            filetype = &#34;OUT&#34;

        elif filetype == &#34;VI/VOTHER&#34;:
            path_to_ordened_file = path_VIOTHER + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;VI&#34;
            filetype = &#34;VI/OTHER&#34;

        elif filetype == &#34;CHECK&#34;:
            path_to_ordened_file = path_CHECK + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;&#34;
            filetype = &#34;CHECK&#34;

        else:
            path_to_ordened_file = path_OTHER + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = &#34;&#34;
            brand = &#34;&#34;
            filetype = &#34;OTHER&#34;

        return {
            &#34;path&#34;: path_to_ordened_file,
            &#34;filetype&#34;: filetype,
            &#34;hash&#34;: hash_of_file,
            &#34;brand&#34;: brand,
        }

    def clean_path(self, base_path: str) -&gt; None:
        &#34;&#34;&#34;Clear files from download and unzip files

        Args:
            base_path (str): path to base files.
        
        &#34;&#34;&#34;
        exclude = [&#34;MASTERCARD&#34;, &#34;VISA&#34;, &#34;OTHER&#34;, &#34;CHECK&#34;, &#34;RESULT&#34;]
        for item in os.listdir(base_path):
            if item not in exclude:
                if os.path.isdir(base_path + &#34;/&#34; + item):
                    os.rmdir(base_path + &#34;/&#34; + item)
                else:
                    os.remove(base_path + &#34;/&#34; + item)

    def unzip_nested(
        self,
        new_path: str,
        complete_path: str,
        path_to_file: str,
        name: str,
        sub: bool = False,
        parent_name: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Unzip files and unzip nested zips into a single folder without directory structures
        
        Args:
            new_path (str): path where file is being saved
            complete_path (str): parent directory of zip file
            path_to_file (str): zipfile
            name (str): name of zip file
            sub (bool): if is sub zip, must initialize in false when is reading directly
            parent_name (str): used only if sub is True, points to parent destiny directory.
        &#34;&#34;&#34;
        pathlib.Path(new_path).mkdir(parents=True, exist_ok=True)
        with zipfile.ZipFile(complete_path) as z:
            for files in z.namelist():
                getfilename = os.path.basename(files)
                if not getfilename:
                    continue
                source = z.open(files)
                if sub:
                    target = open(
                        os.path.join(path_to_file + &#34;/&#34; + parent_name, getfilename),
                        &#34;wb&#34;,
                    )
                else:
                    target = open(
                        os.path.join(path_to_file + &#34;/&#34; + name, getfilename), &#34;wb&#34;
                    )
                with source, target:
                    shutil.copyfileobj(source, target)
                filename_sub = os.fsdecode(getfilename)
                if filename_sub.endswith(&#34;.zip&#34;):
                    name_sub = pathlib.Path(filename_sub).stem
                    if sub:
                        name = parent_name
                    self.unzip_nested(
                        new_path,
                        new_path + &#34;/&#34; + filename_sub,
                        path_to_file,
                        name_sub,
                        True,
                        name,
                    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files"><code class="flex name class">
<span>class <span class="ident">get_files</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class to get and process obtained objects from S3 buckets for interpretation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class get_files:
    &#34;&#34;&#34;Class to get and process obtained objects from S3 buckets for interpretation.&#34;&#34;&#34;
    def __init__(self):
        load_dotenv()
        self.sql = con.connect_to_postgreSQL()
        self.s3 = con.connect_to_s3()
        self.landing = os.getenv(&#34;LANDING_BUCKET&#34;)
        self.log = os.getenv(&#34;LOG_BUCKET&#34;)
        self.raw = os.getenv(&#34;RAW_BUCKET&#34;)
        self.module = &#34;GET FILES&#34;

    def hash_file(self, filename: str) -&gt; str:
        &#34;&#34;&#34;Obtains the hash code of the file to identify any changes

        Args:
            filename (str) : local file path

        Returns:
            str : Hash code generated
        
        &#34;&#34;&#34;
        hash = hlib.sha256()
        block_size = 65536
        with open(filename, &#34;rb&#34;) as file:
            while True:
                data = file.read(block_size)
                if not data:
                    break
                hash.update(data)
        return hash.hexdigest()

    def get_clients(self, client: str = None) -&gt; list:
        &#34;&#34;&#34;Get client&#39;s data or a list of clients
        
        Args:
            client (str) : clients code, or None if needed.
            
        Returns:
            select (list) : gets one or several clients data.
        
        &#34;&#34;&#34;
        try:
            if client == None:
                select = self.sql.select(
                    &#34;CONTROL.T_CUSTOMER&#34;, &#34;WHERE status = &#39;ACTIVE&#39;&#34;
                )
                return select
            else:
                select = self.sql.select(
                    &#34;CONTROL.T_CUSTOMER&#34;, f&#34;WHERE status = &#39;ACTIVE&#39; and code=&#39;{client}&#39;&#34;
                )
                return select
        except ValueError as error:
            return error

    def get_files_from_s3(self, client: str, log_name: str, file: str) -&gt; dict:
        &#34;&#34;&#34;Get files from client&#39;s S3 repository
        
        Args:
            client (str) : clients code.
            log_name (str): log file name.
            file (str): file name.
            
        Returns:
            dict : generated file paths data .
        
        &#34;&#34;&#34;
        date_of_extract = datetime.now()
        formated_date = (
            str(date_of_extract.year)
            + str(date_of_extract.month)
            + str(date_of_extract.day)
            + &#34;_&#34;
            + str(int(datetime.timestamp(date_of_extract)))
        )
        path_to_file = &#34;FILES/&#34; + client + &#34;/&#34; + formated_date
        shutil.rmtree(path_to_file, True)
        pathlib.Path(path_to_file).mkdir(parents=True, exist_ok=True)
        customer_files = self.s3.list_content(self.landing, client + &#34;/&#34; + file)
        for file_obj in customer_files:
            get_zip_name = pathlib.Path(file_obj).name
            if file_obj != (client + &#34;/&#34;):
                log.logs().exist_file(
                    &#34;OPERATIONAL&#34;,
                    client,
                    &#34;INTELICA&#34;,
                    log_name,
                    &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                    &#34;INFO&#34;,
                    &#34;Get file:&#34; + get_zip_name,
                    self.module
                )
                self.s3.get_object(
                    self.landing, file_obj, path_to_file + &#34;/&#34; + get_zip_name
                )
        listofdir = os.listdir(path_to_file)
        for k in listofdir:
            extension = pathlib.Path(k).suffix
            name = pathlib.Path(k).stem
            complete_path = path_to_file + &#34;/&#34; + k
            parent = &#34;&#34;
            if extension == &#34;.zip&#34;:
                log.logs().exist_file(
                    &#34;OPERATIONAL&#34;,
                    client,
                    &#34;INTELICA&#34;,
                    log_name,
                    &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                    &#34;INFO&#34;,
                    &#34;Unzipping file: &#34; + k,
                    self.module
                )
                new_path = path_to_file + &#34;/&#34; + name
                self.unzip_nested(new_path, complete_path, path_to_file, name)
                parent = k
            log.logs().exist_file(
                &#34;OPERATIONAL&#34;,
                client,
                &#34;INTELICA&#34;,
                log_name,
                &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                &#34;INFO&#34;,
                &#34;Start of upload of file: &#34; + client + &#34;/&#34; + formated_date + &#34;/&#34; + k,
                self.module
            )
            self.s3.upload_object(
                self.raw, complete_path, client + &#34;/&#34; + formated_date + &#34;/&#34; + k
            )
            log.logs().exist_file(
                &#34;OPERATIONAL&#34;,
                client,
                &#34;INTELICA&#34;,
                log_name,
                &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                &#34;INFO&#34;,
                &#34;File uploaded on route : &#34; + client + &#34;/&#34; + formated_date + &#34;/&#34; + k,
                self.module
            )

        log.logs().exist_file(
            &#34;OPERATIONAL&#34;,
            client,
            &#34;INTELICA&#34;,
            log_name,
            &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
            &#34;INFO&#34;,
            client + &#34; files moved to repository&#34;,
            self.module
        )
        files = self.sort_files(client, log_name, path_to_file, formated_date)
        self.clean_path(path_to_file)
        return {
            &#34;client&#34;: client,
            &#34;path_to_files&#34;: path_to_file,
            &#34;log_name&#34;: log_name,
            &#34;status&#34;: &#34;finalized&#34;,
            &#34;list_of_files&#34;: files,
            &#34;execution_folder&#34;: formated_date,
        }

    def sort_files(
        self, client, log_name, path_to_files: str, execution_folder: str
    ) -&gt; list:
        &#34;&#34;&#34;navigate and sort files to folders
        
        Args:
            client (str): client code.
            log_name (str): log name file.
            path_to_files (str): path to local files.
            execution_folder (str): parent execution folder.

        Returns:
            list_of_files (list): list of dicts with file data.
        
        &#34;&#34;&#34;
        exclude = [&#34;MASTERCARD&#34;, &#34;VISA&#34;, &#34;OTHER&#34;, &#34;CHECK&#34;, &#34;RESULT&#34;]
        list_of_files = []
        for file in os.listdir(path_to_files):
            if os.path.isdir(path_to_files + &#34;/&#34; + file):
                if file not in exclude:
                    filename = os.fsdecode(file)
                    if filename.endswith(&#34;.zip&#34;):
                        continue
                    else:
                        for file_sub in os.listdir(path_to_files + &#34;/&#34; + file):
                            clasified_file = self.sort_by_name(
                                path_to_files + &#34;/&#34; + file + &#34;/&#34; + file_sub,
                                path_to_files,
                                client,
                            )
                            list_of_files.append(clasified_file)
                            if (
                                clasified_file[&#34;filetype&#34;] == &#34;IN&#34;
                                or clasified_file[&#34;filetype&#34;] == &#34;OUT&#34;
                            ):
                                status = &#34;IN PROGRESS&#34;
                            elif (clasified_file[&#34;filetype&#34;] == &#34;OTHER&#34; or clasified_file[&#34;filetype&#34;] == &#34;CHECK&#34;):
                                status = &#34;REVISION&#34;
                                log.logs().exist_file(
                                    &#34;OPERATIONAL&#34;,
                                    client,
                                    &#34;INTELICA&#34;,
                                    log_name,
                                    &#34;SORTING FILES&#34;,
                                    &#34;WARNING&#34;,
                                    f&#34;File {clasified_file[&#39;path&#39;]} connot be sorted properly.&#34;,
                                    self.module
                                )
                            else:
                                status = &#34;FINISHED&#34;
                            control_files = [
                                (
                                    clasified_file[&#34;hash&#34;],
                                    clasified_file[&#34;brand&#34;],
                                    client,
                                    log_name,
                                    clasified_file[&#34;path&#34;],
                                    date.today(),
                                    date.today(),
                                    &#34;Sorting files&#34;,
                                    status,
                                    clasified_file[&#34;filetype&#34;],
                                    f&#34;{file}.zip&#34;,
                                    execution_folder,
                                )
                            ]
                            con.connect_to_postgreSQL().insert_control_file(
                                control_files
                            )

            else:
                filename = os.fsdecode(file)
                if filename.endswith(&#34;.zip&#34;):
                    continue
                else:
                    clasified_file = self.sort_by_name(
                        path_to_files + &#34;/&#34; + file, path_to_files, client
                    )
                    list_of_files.append(clasified_file)
                    if (
                        clasified_file[&#34;filetype&#34;] == &#34;IN&#34;
                        or clasified_file[&#34;filetype&#34;] == &#34;OUT&#34;
                    ):
                        status = &#34;IN PROGRESS&#34;
                    elif (clasified_file[&#34;filetype&#34;] == &#34;OTHER&#34; or clasified_file[&#34;filetype&#34;] == &#34;CHECK&#34;):
                        status = &#34;REVISION&#34;
                        log.logs().exist_file(
                            &#34;OPERATIONAL&#34;,
                            client,
                            &#34;INTELICA&#34;,
                            log_name,
                            &#34;SORTING FILES&#34;,
                            &#34;WARNING&#34;,
                            f&#34;File {clasified_file[&#39;path&#39;]} connot be sorted properly.&#34;,
                            self.module
                        )
                        
                    else:
                        status = &#34;FINISHED&#34;
                    control_files = [
                        (
                            clasified_file[&#34;hash&#34;],
                            clasified_file[&#34;brand&#34;],
                            client,
                            log_name,
                            clasified_file[&#34;path&#34;],
                            date.today(),
                            date.today(),
                            &#34;Sorted file&#34;,
                            status,
                            clasified_file[&#34;filetype&#34;],
                            &#34;&#34;,
                            execution_folder,
                        )
                    ]
                    con.connect_to_postgreSQL().insert_control_file(control_files)

        return list_of_files

    def sort_by_name(self, path_file: str, path_root: str, client: str) -&gt; dict:
        &#34;&#34;&#34;Creates and sort by brand and file type
        
        Args:
            client (str): client code.
            path_file (str): path to file.
            path_root (str): path to root folder of execution.

        Returns:
            dict : dict with file info.
        
        &#34;&#34;&#34;
        filename = pathlib.Path(path_file).name
        path_MCIN = path_root + &#34;/MASTERCARD/IN&#34;
        path_MCOUT = path_root + &#34;/MASTERCARD/OUT&#34;
        path_MCOTHER = path_root + &#34;/MASTERCARD/OTHER&#34;
        path_VIIN = path_root + &#34;/VISA/IN&#34;
        path_VIOUT = path_root + &#34;/VISA/OUT&#34;
        path_VIOTHER = path_root + &#34;/VISA/OTHER&#34;
        path_OTHER = path_root + &#34;/OTHER&#34;
        path_CHECK = path_root + &#34;/CHECK&#34;
        pathlib.Path(path_MCIN).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_MCOUT).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_MCOTHER).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_VIIN).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_VIOUT).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_VIOTHER).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_OTHER).mkdir(parents=True, exist_ok=True)
        pathlib.Path(path_CHECK).mkdir(parents=True, exist_ok=True)
        query = &#34;where customer_code in(&#39;&#34; + client + &#34;&#39;,&#39;ALL&#39;)&#34;
        list_regex = con.connect_to_postgreSQL().select(
            &#34;control.t_regex&#34;, query, [&#34;file_format&#34;, &#34;file_type&#34;]
        )
        filetype = &#34;OTHER&#34;

        regex_in_MI = []
        regex_in_MO = []
        regex_in_MCO = []
        regex_in_VI = []
        regex_in_VO = []
        regex_in_VIO = []

        for i in list_regex:

            if i[&#34;file_type&#34;] == &#34;MC Incoming&#34;:
                regex_in_MI.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;MC Outgoing&#34;:
                regex_in_MO.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;IAR (T067)&#34;:
                regex_in_MCO.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;VI Incoming&#34;:
                regex_in_VI.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;VI Outgoing&#34;:
                regex_in_VO.append(i[&#34;file_format&#34;])

            elif i[&#34;file_type&#34;] == &#34;ARDEF (EP302)&#34;:
                regex_in_VIO.append(i[&#34;file_format&#34;])

        matches = 0

        for i in regex_in_MI:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;MC/MI&#34;
                matches += 1
                break

        for i in regex_in_MO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;MC/MO&#34;
                matches += 1
                break

        for i in regex_in_MCO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;MC/MCOTHER&#34;
                matches += 1
                break

        for i in regex_in_VI:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;VI/VI&#34;
                matches += 1
                break

        for i in regex_in_VO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;VI/VOUT&#34;
                matches += 1
                break

        for i in regex_in_VIO:
            pattern = re.compile(i)
            if pattern.search(filename):
                filetype = &#34;VI/VOTHER&#34;
                matches += 1
                break

        if matches &gt; 1:
            filetype = &#34;CHECK&#34;

        if filetype == &#34;MC/MI&#34;:
            path_to_ordened_file = path_MCIN + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;MC&#34;
            filetype = &#34;IN&#34;

        elif filetype == &#34;MC/MO&#34;:
            path_to_ordened_file = path_MCOUT + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;MC&#34;
            filetype = &#34;OUT&#34;

        elif filetype == &#34;MC/MCOTHER&#34;:
            path_to_ordened_file = path_MCOTHER + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;MC&#34;
            filetype = &#34;MC/OTHER&#34;

        elif filetype == &#34;VI/VI&#34;:
            path_to_ordened_file = path_VIIN + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;VI&#34;
            filetype = &#34;IN&#34;

        elif filetype == &#34;VI/VOUT&#34;:
            path_to_ordened_file = path_VIOUT + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;VI&#34;
            filetype = &#34;OUT&#34;

        elif filetype == &#34;VI/VOTHER&#34;:
            path_to_ordened_file = path_VIOTHER + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;VI&#34;
            filetype = &#34;VI/OTHER&#34;

        elif filetype == &#34;CHECK&#34;:
            path_to_ordened_file = path_CHECK + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = self.hash_file(path_to_ordened_file)
            brand = &#34;&#34;
            filetype = &#34;CHECK&#34;

        else:
            path_to_ordened_file = path_OTHER + &#34;/&#34; + filename
            os.replace(path_file, path_to_ordened_file)
            hash_of_file = &#34;&#34;
            brand = &#34;&#34;
            filetype = &#34;OTHER&#34;

        return {
            &#34;path&#34;: path_to_ordened_file,
            &#34;filetype&#34;: filetype,
            &#34;hash&#34;: hash_of_file,
            &#34;brand&#34;: brand,
        }

    def clean_path(self, base_path: str) -&gt; None:
        &#34;&#34;&#34;Clear files from download and unzip files

        Args:
            base_path (str): path to base files.
        
        &#34;&#34;&#34;
        exclude = [&#34;MASTERCARD&#34;, &#34;VISA&#34;, &#34;OTHER&#34;, &#34;CHECK&#34;, &#34;RESULT&#34;]
        for item in os.listdir(base_path):
            if item not in exclude:
                if os.path.isdir(base_path + &#34;/&#34; + item):
                    os.rmdir(base_path + &#34;/&#34; + item)
                else:
                    os.remove(base_path + &#34;/&#34; + item)

    def unzip_nested(
        self,
        new_path: str,
        complete_path: str,
        path_to_file: str,
        name: str,
        sub: bool = False,
        parent_name: str | None = None,
    ) -&gt; None:
        &#34;&#34;&#34;Unzip files and unzip nested zips into a single folder without directory structures
        
        Args:
            new_path (str): path where file is being saved
            complete_path (str): parent directory of zip file
            path_to_file (str): zipfile
            name (str): name of zip file
            sub (bool): if is sub zip, must initialize in false when is reading directly
            parent_name (str): used only if sub is True, points to parent destiny directory.
        &#34;&#34;&#34;
        pathlib.Path(new_path).mkdir(parents=True, exist_ok=True)
        with zipfile.ZipFile(complete_path) as z:
            for files in z.namelist():
                getfilename = os.path.basename(files)
                if not getfilename:
                    continue
                source = z.open(files)
                if sub:
                    target = open(
                        os.path.join(path_to_file + &#34;/&#34; + parent_name, getfilename),
                        &#34;wb&#34;,
                    )
                else:
                    target = open(
                        os.path.join(path_to_file + &#34;/&#34; + name, getfilename), &#34;wb&#34;
                    )
                with source, target:
                    shutil.copyfileobj(source, target)
                filename_sub = os.fsdecode(getfilename)
                if filename_sub.endswith(&#34;.zip&#34;):
                    name_sub = pathlib.Path(filename_sub).stem
                    if sub:
                        name = parent_name
                    self.unzip_nested(
                        new_path,
                        new_path + &#34;/&#34; + filename_sub,
                        path_to_file,
                        name_sub,
                        True,
                        name,
                    )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.clean_path"><code class="name flex">
<span>def <span class="ident">clean_path</span></span>(<span>self, base_path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Clear files from download and unzip files</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>base_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path to base files.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_path(self, base_path: str) -&gt; None:
    &#34;&#34;&#34;Clear files from download and unzip files

    Args:
        base_path (str): path to base files.
    
    &#34;&#34;&#34;
    exclude = [&#34;MASTERCARD&#34;, &#34;VISA&#34;, &#34;OTHER&#34;, &#34;CHECK&#34;, &#34;RESULT&#34;]
    for item in os.listdir(base_path):
        if item not in exclude:
            if os.path.isdir(base_path + &#34;/&#34; + item):
                os.rmdir(base_path + &#34;/&#34; + item)
            else:
                os.remove(base_path + &#34;/&#34; + item)</code></pre>
</details>
</dd>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.get_clients"><code class="name flex">
<span>def <span class="ident">get_clients</span></span>(<span>self, client: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Get client's data or a list of clients</p>
<h2 id="args">Args</h2>
<p>client (str) : clients code, or None if needed.</p>
<h2 id="returns">Returns</h2>
<p>select (list) : gets one or several clients data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_clients(self, client: str = None) -&gt; list:
    &#34;&#34;&#34;Get client&#39;s data or a list of clients
    
    Args:
        client (str) : clients code, or None if needed.
        
    Returns:
        select (list) : gets one or several clients data.
    
    &#34;&#34;&#34;
    try:
        if client == None:
            select = self.sql.select(
                &#34;CONTROL.T_CUSTOMER&#34;, &#34;WHERE status = &#39;ACTIVE&#39;&#34;
            )
            return select
        else:
            select = self.sql.select(
                &#34;CONTROL.T_CUSTOMER&#34;, f&#34;WHERE status = &#39;ACTIVE&#39; and code=&#39;{client}&#39;&#34;
            )
            return select
    except ValueError as error:
        return error</code></pre>
</details>
</dd>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.get_files_from_s3"><code class="name flex">
<span>def <span class="ident">get_files_from_s3</span></span>(<span>self, client: str, log_name: str, file: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get files from client's S3 repository</p>
<h2 id="args">Args</h2>
<dl>
<dt>client (str) : clients code.</dt>
<dt><strong><code>log_name</code></strong> :&ensp;<code>str</code></dt>
<dd>log file name.</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>str</code></dt>
<dd>file name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict </code></dt>
<dd>generated file paths data .</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_files_from_s3(self, client: str, log_name: str, file: str) -&gt; dict:
    &#34;&#34;&#34;Get files from client&#39;s S3 repository
    
    Args:
        client (str) : clients code.
        log_name (str): log file name.
        file (str): file name.
        
    Returns:
        dict : generated file paths data .
    
    &#34;&#34;&#34;
    date_of_extract = datetime.now()
    formated_date = (
        str(date_of_extract.year)
        + str(date_of_extract.month)
        + str(date_of_extract.day)
        + &#34;_&#34;
        + str(int(datetime.timestamp(date_of_extract)))
    )
    path_to_file = &#34;FILES/&#34; + client + &#34;/&#34; + formated_date
    shutil.rmtree(path_to_file, True)
    pathlib.Path(path_to_file).mkdir(parents=True, exist_ok=True)
    customer_files = self.s3.list_content(self.landing, client + &#34;/&#34; + file)
    for file_obj in customer_files:
        get_zip_name = pathlib.Path(file_obj).name
        if file_obj != (client + &#34;/&#34;):
            log.logs().exist_file(
                &#34;OPERATIONAL&#34;,
                client,
                &#34;INTELICA&#34;,
                log_name,
                &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                &#34;INFO&#34;,
                &#34;Get file:&#34; + get_zip_name,
                self.module
            )
            self.s3.get_object(
                self.landing, file_obj, path_to_file + &#34;/&#34; + get_zip_name
            )
    listofdir = os.listdir(path_to_file)
    for k in listofdir:
        extension = pathlib.Path(k).suffix
        name = pathlib.Path(k).stem
        complete_path = path_to_file + &#34;/&#34; + k
        parent = &#34;&#34;
        if extension == &#34;.zip&#34;:
            log.logs().exist_file(
                &#34;OPERATIONAL&#34;,
                client,
                &#34;INTELICA&#34;,
                log_name,
                &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
                &#34;INFO&#34;,
                &#34;Unzipping file: &#34; + k,
                self.module
            )
            new_path = path_to_file + &#34;/&#34; + name
            self.unzip_nested(new_path, complete_path, path_to_file, name)
            parent = k
        log.logs().exist_file(
            &#34;OPERATIONAL&#34;,
            client,
            &#34;INTELICA&#34;,
            log_name,
            &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
            &#34;INFO&#34;,
            &#34;Start of upload of file: &#34; + client + &#34;/&#34; + formated_date + &#34;/&#34; + k,
            self.module
        )
        self.s3.upload_object(
            self.raw, complete_path, client + &#34;/&#34; + formated_date + &#34;/&#34; + k
        )
        log.logs().exist_file(
            &#34;OPERATIONAL&#34;,
            client,
            &#34;INTELICA&#34;,
            log_name,
            &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
            &#34;INFO&#34;,
            &#34;File uploaded on route : &#34; + client + &#34;/&#34; + formated_date + &#34;/&#34; + k,
            self.module
        )

    log.logs().exist_file(
        &#34;OPERATIONAL&#34;,
        client,
        &#34;INTELICA&#34;,
        log_name,
        &#34;GETTING FILES FROM S3 REPOSITORY&#34;,
        &#34;INFO&#34;,
        client + &#34; files moved to repository&#34;,
        self.module
    )
    files = self.sort_files(client, log_name, path_to_file, formated_date)
    self.clean_path(path_to_file)
    return {
        &#34;client&#34;: client,
        &#34;path_to_files&#34;: path_to_file,
        &#34;log_name&#34;: log_name,
        &#34;status&#34;: &#34;finalized&#34;,
        &#34;list_of_files&#34;: files,
        &#34;execution_folder&#34;: formated_date,
    }</code></pre>
</details>
</dd>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.hash_file"><code class="name flex">
<span>def <span class="ident">hash_file</span></span>(<span>self, filename: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Obtains the hash code of the file to identify any changes</p>
<h2 id="args">Args</h2>
<p>filename (str) : local file path</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str </code></dt>
<dd>Hash code generated</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash_file(self, filename: str) -&gt; str:
    &#34;&#34;&#34;Obtains the hash code of the file to identify any changes

    Args:
        filename (str) : local file path

    Returns:
        str : Hash code generated
    
    &#34;&#34;&#34;
    hash = hlib.sha256()
    block_size = 65536
    with open(filename, &#34;rb&#34;) as file:
        while True:
            data = file.read(block_size)
            if not data:
                break
            hash.update(data)
    return hash.hexdigest()</code></pre>
</details>
</dd>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.sort_by_name"><code class="name flex">
<span>def <span class="ident">sort_by_name</span></span>(<span>self, path_file: str, path_root: str, client: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and sort by brand and file type</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>str</code></dt>
<dd>client code.</dd>
<dt><strong><code>path_file</code></strong> :&ensp;<code>str</code></dt>
<dd>path to file.</dd>
<dt><strong><code>path_root</code></strong> :&ensp;<code>str</code></dt>
<dd>path to root folder of execution.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict </code></dt>
<dd>dict with file info.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_by_name(self, path_file: str, path_root: str, client: str) -&gt; dict:
    &#34;&#34;&#34;Creates and sort by brand and file type
    
    Args:
        client (str): client code.
        path_file (str): path to file.
        path_root (str): path to root folder of execution.

    Returns:
        dict : dict with file info.
    
    &#34;&#34;&#34;
    filename = pathlib.Path(path_file).name
    path_MCIN = path_root + &#34;/MASTERCARD/IN&#34;
    path_MCOUT = path_root + &#34;/MASTERCARD/OUT&#34;
    path_MCOTHER = path_root + &#34;/MASTERCARD/OTHER&#34;
    path_VIIN = path_root + &#34;/VISA/IN&#34;
    path_VIOUT = path_root + &#34;/VISA/OUT&#34;
    path_VIOTHER = path_root + &#34;/VISA/OTHER&#34;
    path_OTHER = path_root + &#34;/OTHER&#34;
    path_CHECK = path_root + &#34;/CHECK&#34;
    pathlib.Path(path_MCIN).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path_MCOUT).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path_MCOTHER).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path_VIIN).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path_VIOUT).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path_VIOTHER).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path_OTHER).mkdir(parents=True, exist_ok=True)
    pathlib.Path(path_CHECK).mkdir(parents=True, exist_ok=True)
    query = &#34;where customer_code in(&#39;&#34; + client + &#34;&#39;,&#39;ALL&#39;)&#34;
    list_regex = con.connect_to_postgreSQL().select(
        &#34;control.t_regex&#34;, query, [&#34;file_format&#34;, &#34;file_type&#34;]
    )
    filetype = &#34;OTHER&#34;

    regex_in_MI = []
    regex_in_MO = []
    regex_in_MCO = []
    regex_in_VI = []
    regex_in_VO = []
    regex_in_VIO = []

    for i in list_regex:

        if i[&#34;file_type&#34;] == &#34;MC Incoming&#34;:
            regex_in_MI.append(i[&#34;file_format&#34;])

        elif i[&#34;file_type&#34;] == &#34;MC Outgoing&#34;:
            regex_in_MO.append(i[&#34;file_format&#34;])

        elif i[&#34;file_type&#34;] == &#34;IAR (T067)&#34;:
            regex_in_MCO.append(i[&#34;file_format&#34;])

        elif i[&#34;file_type&#34;] == &#34;VI Incoming&#34;:
            regex_in_VI.append(i[&#34;file_format&#34;])

        elif i[&#34;file_type&#34;] == &#34;VI Outgoing&#34;:
            regex_in_VO.append(i[&#34;file_format&#34;])

        elif i[&#34;file_type&#34;] == &#34;ARDEF (EP302)&#34;:
            regex_in_VIO.append(i[&#34;file_format&#34;])

    matches = 0

    for i in regex_in_MI:
        pattern = re.compile(i)
        if pattern.search(filename):
            filetype = &#34;MC/MI&#34;
            matches += 1
            break

    for i in regex_in_MO:
        pattern = re.compile(i)
        if pattern.search(filename):
            filetype = &#34;MC/MO&#34;
            matches += 1
            break

    for i in regex_in_MCO:
        pattern = re.compile(i)
        if pattern.search(filename):
            filetype = &#34;MC/MCOTHER&#34;
            matches += 1
            break

    for i in regex_in_VI:
        pattern = re.compile(i)
        if pattern.search(filename):
            filetype = &#34;VI/VI&#34;
            matches += 1
            break

    for i in regex_in_VO:
        pattern = re.compile(i)
        if pattern.search(filename):
            filetype = &#34;VI/VOUT&#34;
            matches += 1
            break

    for i in regex_in_VIO:
        pattern = re.compile(i)
        if pattern.search(filename):
            filetype = &#34;VI/VOTHER&#34;
            matches += 1
            break

    if matches &gt; 1:
        filetype = &#34;CHECK&#34;

    if filetype == &#34;MC/MI&#34;:
        path_to_ordened_file = path_MCIN + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = self.hash_file(path_to_ordened_file)
        brand = &#34;MC&#34;
        filetype = &#34;IN&#34;

    elif filetype == &#34;MC/MO&#34;:
        path_to_ordened_file = path_MCOUT + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = self.hash_file(path_to_ordened_file)
        brand = &#34;MC&#34;
        filetype = &#34;OUT&#34;

    elif filetype == &#34;MC/MCOTHER&#34;:
        path_to_ordened_file = path_MCOTHER + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = self.hash_file(path_to_ordened_file)
        brand = &#34;MC&#34;
        filetype = &#34;MC/OTHER&#34;

    elif filetype == &#34;VI/VI&#34;:
        path_to_ordened_file = path_VIIN + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = self.hash_file(path_to_ordened_file)
        brand = &#34;VI&#34;
        filetype = &#34;IN&#34;

    elif filetype == &#34;VI/VOUT&#34;:
        path_to_ordened_file = path_VIOUT + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = self.hash_file(path_to_ordened_file)
        brand = &#34;VI&#34;
        filetype = &#34;OUT&#34;

    elif filetype == &#34;VI/VOTHER&#34;:
        path_to_ordened_file = path_VIOTHER + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = self.hash_file(path_to_ordened_file)
        brand = &#34;VI&#34;
        filetype = &#34;VI/OTHER&#34;

    elif filetype == &#34;CHECK&#34;:
        path_to_ordened_file = path_CHECK + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = self.hash_file(path_to_ordened_file)
        brand = &#34;&#34;
        filetype = &#34;CHECK&#34;

    else:
        path_to_ordened_file = path_OTHER + &#34;/&#34; + filename
        os.replace(path_file, path_to_ordened_file)
        hash_of_file = &#34;&#34;
        brand = &#34;&#34;
        filetype = &#34;OTHER&#34;

    return {
        &#34;path&#34;: path_to_ordened_file,
        &#34;filetype&#34;: filetype,
        &#34;hash&#34;: hash_of_file,
        &#34;brand&#34;: brand,
    }</code></pre>
</details>
</dd>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.sort_files"><code class="name flex">
<span>def <span class="ident">sort_files</span></span>(<span>self, client, log_name, path_to_files: str, execution_folder: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>navigate and sort files to folders</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>client</code></strong> :&ensp;<code>str</code></dt>
<dd>client code.</dd>
<dt><strong><code>log_name</code></strong> :&ensp;<code>str</code></dt>
<dd>log name file.</dd>
<dt><strong><code>path_to_files</code></strong> :&ensp;<code>str</code></dt>
<dd>path to local files.</dd>
<dt><strong><code>execution_folder</code></strong> :&ensp;<code>str</code></dt>
<dd>parent execution folder.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list_of_files (list): list of dicts with file data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort_files(
    self, client, log_name, path_to_files: str, execution_folder: str
) -&gt; list:
    &#34;&#34;&#34;navigate and sort files to folders
    
    Args:
        client (str): client code.
        log_name (str): log name file.
        path_to_files (str): path to local files.
        execution_folder (str): parent execution folder.

    Returns:
        list_of_files (list): list of dicts with file data.
    
    &#34;&#34;&#34;
    exclude = [&#34;MASTERCARD&#34;, &#34;VISA&#34;, &#34;OTHER&#34;, &#34;CHECK&#34;, &#34;RESULT&#34;]
    list_of_files = []
    for file in os.listdir(path_to_files):
        if os.path.isdir(path_to_files + &#34;/&#34; + file):
            if file not in exclude:
                filename = os.fsdecode(file)
                if filename.endswith(&#34;.zip&#34;):
                    continue
                else:
                    for file_sub in os.listdir(path_to_files + &#34;/&#34; + file):
                        clasified_file = self.sort_by_name(
                            path_to_files + &#34;/&#34; + file + &#34;/&#34; + file_sub,
                            path_to_files,
                            client,
                        )
                        list_of_files.append(clasified_file)
                        if (
                            clasified_file[&#34;filetype&#34;] == &#34;IN&#34;
                            or clasified_file[&#34;filetype&#34;] == &#34;OUT&#34;
                        ):
                            status = &#34;IN PROGRESS&#34;
                        elif (clasified_file[&#34;filetype&#34;] == &#34;OTHER&#34; or clasified_file[&#34;filetype&#34;] == &#34;CHECK&#34;):
                            status = &#34;REVISION&#34;
                            log.logs().exist_file(
                                &#34;OPERATIONAL&#34;,
                                client,
                                &#34;INTELICA&#34;,
                                log_name,
                                &#34;SORTING FILES&#34;,
                                &#34;WARNING&#34;,
                                f&#34;File {clasified_file[&#39;path&#39;]} connot be sorted properly.&#34;,
                                self.module
                            )
                        else:
                            status = &#34;FINISHED&#34;
                        control_files = [
                            (
                                clasified_file[&#34;hash&#34;],
                                clasified_file[&#34;brand&#34;],
                                client,
                                log_name,
                                clasified_file[&#34;path&#34;],
                                date.today(),
                                date.today(),
                                &#34;Sorting files&#34;,
                                status,
                                clasified_file[&#34;filetype&#34;],
                                f&#34;{file}.zip&#34;,
                                execution_folder,
                            )
                        ]
                        con.connect_to_postgreSQL().insert_control_file(
                            control_files
                        )

        else:
            filename = os.fsdecode(file)
            if filename.endswith(&#34;.zip&#34;):
                continue
            else:
                clasified_file = self.sort_by_name(
                    path_to_files + &#34;/&#34; + file, path_to_files, client
                )
                list_of_files.append(clasified_file)
                if (
                    clasified_file[&#34;filetype&#34;] == &#34;IN&#34;
                    or clasified_file[&#34;filetype&#34;] == &#34;OUT&#34;
                ):
                    status = &#34;IN PROGRESS&#34;
                elif (clasified_file[&#34;filetype&#34;] == &#34;OTHER&#34; or clasified_file[&#34;filetype&#34;] == &#34;CHECK&#34;):
                    status = &#34;REVISION&#34;
                    log.logs().exist_file(
                        &#34;OPERATIONAL&#34;,
                        client,
                        &#34;INTELICA&#34;,
                        log_name,
                        &#34;SORTING FILES&#34;,
                        &#34;WARNING&#34;,
                        f&#34;File {clasified_file[&#39;path&#39;]} connot be sorted properly.&#34;,
                        self.module
                    )
                    
                else:
                    status = &#34;FINISHED&#34;
                control_files = [
                    (
                        clasified_file[&#34;hash&#34;],
                        clasified_file[&#34;brand&#34;],
                        client,
                        log_name,
                        clasified_file[&#34;path&#34;],
                        date.today(),
                        date.today(),
                        &#34;Sorted file&#34;,
                        status,
                        clasified_file[&#34;filetype&#34;],
                        &#34;&#34;,
                        execution_folder,
                    )
                ]
                con.connect_to_postgreSQL().insert_control_file(control_files)

    return list_of_files</code></pre>
</details>
</dd>
<dt id="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.unzip_nested"><code class="name flex">
<span>def <span class="ident">unzip_nested</span></span>(<span>self, new_path: str, complete_path: str, path_to_file: str, name: str, sub: bool = False, parent_name: str | None = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Unzip files and unzip nested zips into a single folder without directory structures</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>new_path</code></strong> :&ensp;<code>str</code></dt>
<dd>path where file is being saved</dd>
<dt><strong><code>complete_path</code></strong> :&ensp;<code>str</code></dt>
<dd>parent directory of zip file</dd>
<dt><strong><code>path_to_file</code></strong> :&ensp;<code>str</code></dt>
<dd>zipfile</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of zip file</dd>
<dt><strong><code>sub</code></strong> :&ensp;<code>bool</code></dt>
<dd>if is sub zip, must initialize in false when is reading directly</dd>
<dt><strong><code>parent_name</code></strong> :&ensp;<code>str</code></dt>
<dd>used only if sub is True, points to parent destiny directory.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unzip_nested(
    self,
    new_path: str,
    complete_path: str,
    path_to_file: str,
    name: str,
    sub: bool = False,
    parent_name: str | None = None,
) -&gt; None:
    &#34;&#34;&#34;Unzip files and unzip nested zips into a single folder without directory structures
    
    Args:
        new_path (str): path where file is being saved
        complete_path (str): parent directory of zip file
        path_to_file (str): zipfile
        name (str): name of zip file
        sub (bool): if is sub zip, must initialize in false when is reading directly
        parent_name (str): used only if sub is True, points to parent destiny directory.
    &#34;&#34;&#34;
    pathlib.Path(new_path).mkdir(parents=True, exist_ok=True)
    with zipfile.ZipFile(complete_path) as z:
        for files in z.namelist():
            getfilename = os.path.basename(files)
            if not getfilename:
                continue
            source = z.open(files)
            if sub:
                target = open(
                    os.path.join(path_to_file + &#34;/&#34; + parent_name, getfilename),
                    &#34;wb&#34;,
                )
            else:
                target = open(
                    os.path.join(path_to_file + &#34;/&#34; + name, getfilename), &#34;wb&#34;
                )
            with source, target:
                shutil.copyfileobj(source, target)
            filename_sub = os.fsdecode(getfilename)
            if filename_sub.endswith(&#34;.zip&#34;):
                name_sub = pathlib.Path(filename_sub).stem
                if sub:
                    name = parent_name
                self.unzip_nested(
                    new_path,
                    new_path + &#34;/&#34; + filename_sub,
                    path_to_file,
                    name_sub,
                    True,
                    name,
                )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles" href="index.html">PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files">get_files</a></code></h4>
<ul class="two-column">
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.clean_path" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.clean_path">clean_path</a></code></li>
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.get_clients" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.get_clients">get_clients</a></code></li>
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.get_files_from_s3" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.get_files_from_s3">get_files_from_s3</a></code></li>
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.hash_file" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.hash_file">hash_file</a></code></li>
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.sort_by_name" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.sort_by_name">sort_by_name</a></code></li>
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.sort_files" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.sort_files">sort_files</a></code></li>
<li><code><a title="PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.unzip_nested" href="#PROY-INTELICA-INTERCAMBIO-2022.Module.GetFiles.getfiles.get_files.unzip_nested">unzip_nested</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>